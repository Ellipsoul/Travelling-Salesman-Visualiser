<h2 mat-dialog-title class="dialog-title" [style.display]="infoPageNumber==0 ? 'block':'none'">
  Welcome to the <br> Travelling Salesman Problem Visualiser!
</h2>
<h2 mat-dialog-title class="dialog-title" [style.display]="infoPageNumber==1 ? 'block':'none'">
  What is the Travelling Salesman Problem?
</h2>
<h2 mat-dialog-title class="dialog-title" [style.display]="infoPageNumber==2 ? 'block':'none'">
  Using this Application
</h2>
<h2 mat-dialog-title class="dialog-title" [style.display]="infoPageNumber==3 ? 'block':'none'">
  Summary of Brute Force Algorithms
</h2>
<h2 mat-dialog-title class="dialog-title" [style.display]="infoPageNumber==4 ? 'block':'none'">
  Summary of Heuristic Algorithms
</h2>
<h2 mat-dialog-title class="dialog-title" [style.display]="infoPageNumber==5 ? 'block':'none'">
  Thank You!
</h2>

<div class="dialog-content">
  <mat-dialog-content class="dialog-text">

    <div [style.display]="infoPageNumber==0 ? 'inline':'none'">
      <h2 id="thank-you"> Thank you for visiting our application! </h2>
      <h3 id="tutorial"> This short tutorial will: </h3>
      <ul>
        <li> Introduce the Travelling Salesman Problem </li>
        <li> Provide instructions on how to use this app </li>
        <li> Explain each algorithm's implementation </li>
      </ul>
    <h2 id="fun"> <b> Have Fun! </b></h2>
    <img src="assets/img/TSP_logo.png" id="logo-large">
    </div>

    <div [style.display]="infoPageNumber==1 ? 'inline':'none'">
      <p id="tsp-explanation"> The travelling salesman problem is a very simple problem to explain, but an <i> extremely </i> difficult problem to solve efficiently. In computer science, this problem is classified as an <i> NP-Hard</i> problem, meaning that it cannot be solved in polynomial time or better, and a potentially optimal route cannot be verified as optimal in polynomial time or better.</p>
      <ul>
        <li class="tsp-explanation-list"> A traveller has several cities (<b>nodes</b>/<b>vertices</b>) he/she would like to visit.</li>
        <li class="tsp-explanation-list"> The traveller must visit all nodes exactly once and return to the original node (this is known as a <b>Hamiltonian Cycle</b>), and the goal is to find the path that <i>minimises</i> the traveller's total distance travelled.</li>
        <li class="tsp-explanation-list"> That's it! From vehicle routing to planning and logistics, the applications for this problem are endless! </li>
      </ul>
      <img src="assets/img/TSP_Path.png" id="tsp-example-img">
    </div>

    <div [style.display]="infoPageNumber==2 ? 'inline':'none'">
      <p id="unlike-p"> Unlike this problem, using this app is very easy! </p>
      <ol>
        <li class="app-guide-li">
          Select an algorithm
          <img src="assets/img/select_algorithm.png" id="select-algorithm-img">
        </li>
        <li class="app-guide-li">
          Create some points
          <ul>
            <li class="app-guide-li"> Use the point randomiser to generate a random distribution, or initialise your own by manually selecting points in the grid </li>
            <img src="assets/img/select_points.png" id="select-points-img">
          </ul>
        </li>
        <li class="app-guide-li">
            Press Start!
            <ul>
              <li class="app-guide-li"> Adjust the playspeed to your liking </li>
              <li class="app-guide-li"> Observe the path distance of the current and most optimal iteration </li>
            </ul>
        </li>
        <img src="assets/img/press_start.png" id="press-start-img">
      </ol>
    </div>

    <div [style.display]="infoPageNumber==3 ? 'inline':'none'">
      <h3> Brute Force Algorithms attempt to find the exact solution by checking all possible paths. These algorithms typically becomes impractical quite quickly as the number of cities increases. </h3>
      <ul>
        <li>
          <b>Depth First Search</b>
          <ul>
            <li class="algorithm-explanations"> This algorithm traverses each possible cycle in a <i>depth first search </i> manner, continuing until all possible paths are checked.  </li>
            <li class="algorithm-explanations"> The length of each cycle is calculated, and the cycle of mininum length is saved. </li>
          </ul>
        </li>
        <li>
          <b>Branch and Bound</b>
          <ul>
            <li class="algorithm-explanations"> Traverses in the same manner as <i>depth first search</i> but with a small optimisation:</li>
            <li class="algorithm-explanations"> If the current distance of a sub-path already exceeds the previous minimum of a full cycle, the remaining branches in this subtree are skipped as they cannot contain a full cycle with a shorter distance than the previous minimum distance cycle.</li>
          </ul>
        </li>
        <li>
          <b>Random Search</b>
          <ul>
            <li class="algorithm-explanations"> As the name suggests, this algorithm simply initialises Hamiltonian cycles randomly amongst the points, and calculates the path's corresponding distance. </li>
            <li class="algorithm-explanations"> This algorithm will run endlessly until stopped! </li>
          </ul>
        </li>
      </ul>
    </div>

    <div [style.display]="infoPageNumber==4 ? 'inline':'none'">
      <h3> Heuristic algorithms do not guarantee an optimal cycle, but aim to find a close approximation to the theoretical optimal route in significantly less time. These algorithms can be completed in <i> polynomial time</i>. </h3>
      <ul>
        <li>
          <b>Nearest Neighbour</b>
          <ul>
            <li class="algorithm-explanations2"> The <i>greedy</i> approach. The algorithm initialises a random starting node, and at each timestep searches for the closest node to the previous node that is not already part of the cycle and connects a path between the two nodes, until a complete cycle is formed. </li>
          </ul>
        </li>
        <li>
          <b>Nearest Insertion, Farthest Insertion and Arbitrary Insertion</b>
          <ul>
            <li class="algorithm-explanations2"> These algorithms all begin in the same fashion: a random starting node is selected and connected to its nearest neighbouring node to form the first path. </li>
            <li class="algorithm-explanations2"> Now, the algorithms search for a new node to add to the cycle. For <i>nearest insertion</i>, the <i>closest</i> node to any in-cycle node is selected. For <i>farthest insertion</i>, the <i>farthest</i> node is selected, and for <i>arbitrary insertion</i> a <i>random</i> node is selected.</li>
            <li class="algorithm-explanations2"> The selected node is <i>inserted</i> between two other connected nodes where the <i>path distance increase</i> from the insertion is <i>minimised</i>. This repeats until all nodes have been inserted into the cycle. </li>
          </ul>
        </li>
        <li>
          <b>Convex Hull</b>
          <ul>
            <li class="algorithm-explanations"> We may need to re-arrange this a litte.. </li>
          </ul>
        </li>
      </ul>
    </div>

    <div [style.display]="infoPageNumber==5 ? 'inline':'none'">
      <h2> We hope you enjoyed our app! </h2>
      <h3> This project was completed purely out of computer science and software engineering curiosity. </h3>
      <h3> Click the image below to view the application source code! </h3>
      <div style="text-align: center;">
        <a href="https://github.com/Ellipsoul/Travelling-Salesman-Visualiser" target="_blank" style="text-align:center">
          <img src="assets/img/TSP_logo.png" id="logo-large-end">
        </a>
      </div>
      <h3>Created By:</h3>
      <div>
        <span class="column">
          <a href="https://github.com/Ellipsoul" target="_blank">
            <img src="assets/img/github_mark.png" id="github-mark">
          </a>
          <p id="name-aron"> Aron Teh </p>
        </span>
        <span class="column">
          <a href="https://github.com/juicetinliu" target="_blank">
            <img src="assets/img/github_mark.png" id="github-mark">
          </a>
          <p id="name-justin"> Justin Liu </p>
        </span>
      </div>

    </div>

  </mat-dialog-content>

</div>

<mat-dialog-actions>
  <div class="dialog-buttons">
    <button
      mat-stroked-button
      color="primary"
      [disabled]="infoPageNumber==0"
      (mousedown)="decrementPage()"
      id="prev-button"
    >
      Previous
    </button>
    <button
      mat-stroked-button
      color="primary"
      [disabled]="infoPageNumber==5"
      (mousedown)="incrementPage()"
      id="next-button"
    >
      Next
    </button>

    <button mat-stroked-button mat-dialog-close color="basic" id="close-button"> Close </button>

  </div>
</mat-dialog-actions>
